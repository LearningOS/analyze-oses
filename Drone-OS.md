# Drone OS

## 概念

一个用 Rust 编写实时应用程序的嵌入式操作系统。

Drone 是一个嵌入式操作系统，用于基于 Rust 编写实时应用程序。 它旨在将不影响性能的现代开发方法引入嵌入式编程中。



## 支持的硬件

Drone可以运行于这些架构：` ARMv7-M`, `ARMv8-M`, `RISC-V`

已经运行测试过的硬件包括： 

* Cortex®-M3, Cortex®-M4, Cortex®-M33, Nuclei Bumblebee 核；

* STM32, NRF52, NRF91, GD32VF103 MCU 系列；

添加一种新的硬件架构的支持，必须实现原子的CAS操作 `atomic compare-and-swap` 。这是由于Drone 高度依赖于良好的硬件原子操作的支持。

对于调试，Drone工具提供了对`J-Link`和`Black Magic Probe`的本地支持，以及对`OpenOCD`的通用接口。



### drone工程部署

Drone 基于cargo命令工具进行嵌入式代码开发。支持多种目标芯片及调试，例如烧录hello-world程序。

Drone命令行工具，可以为特定硬件生成一个新的项目，或者用于管理调试代码zh。



* 工程代码创建

* 镜像烧写
* 运行的log输出



Justfile 编译

工程项目的编译配置 构建系统。配方`recipes`存放于 `justfile` 的文件中，其语法受 `make` 启发，`just` 有很多很棒的特性，而且相比 `make` 有很多改进。



### async异步

Drone提供了使用本地`async/await`语法和执行`Future`所需的所有运行时的支持。

每个中断都是一个async异步任务的执行器。 

基于 Rust 的方便的异步编程，中断handler处理程序`async fn handler()`，类似传统的同步代码，单不需要单独的堆栈。



### 动态内存allocator 

Drone 包含一个动态内存分配器，借此可以使用 Rust 的 Box、Vec、String、Arc 和其他动态类型。它是无锁的、确定性的，并且代码占用空间小，这使得它即使在简单的微控制器上也很有用。 代价是它需要针对每个特定应用程序进行调整。 Drone 提供了用于收集实时allocator的统计数据和计算优化的布局配置的程序，以自动执行这些操作。

* 堆内存trace: `just heaptrace` ；

* 优化的内存布局：`drone heap generate --pools 8` 可于配置文件`Drone.toml`中配置；

Drone的主栈都有栈溢出保护，无论MMU/MPU是否存在。但是二级堆栈的任务需要MMU/MPU来确保安全。



### 内存映射寄存器

提供了安全地使用内存映射的寄存器的API。 应用程序可以开始使用 一组用于所有可用寄存器的大小为零的唯一标记`token`。 token可以具有move或copy语义，可以是可共享的原子式访问，也可以是不可共享的非原子式访问，可以拆分为单独的寄存器字段标记`token`。

Drone从供应商提供的`SVD`文件中自动生成rust的寄存器定义。



### 线程

Drone使用基于中断的抢占式优先级调度，具有相同优先级的任务被合作执行。

一个应用程序具有，与硬件中断相对应的，预定义的线程数。不过每个线程可以运行动态多数量的`fiber`函数。



### 通用外设

寄存器和单独的寄存器字段可以被分组为外围块。在抽象一个外设类型的不同实例方面，做了很多工作，即使这些实例只有微小差异。

如GPIO引脚设置；



### 安全

Drone为固有的不安全底层操作，提供安全的API。唯一需要的不安全函数是位于`src/bin.rs` 的入口，它是一个独立的编译单元。

其实可以在src/lib.rs的头部用`#![forbid(unsafe_code)]`编写整个微控制器的固件，以静态地保证只写安全的 Rust代码。



### 打印LOG

Drone提供了一个按照ARM串行线输出设计的，抽象记录LOG接口。可通过通用的 USB-UART 串口适配器输出。

它有32个多路复用的数据流，并支持最大32位的原子数据包。

提供熟悉的Rust宏，如` print!`, `eprint!`, `dbg!`，被映射到保留的0和1端口，分别作为标准输出和标准错误输出。

用其他端口进行输出：`Port::new(3).write::<u32>(0xABFF_FFCD).write::<u32>(0xDCFF_FFBA);`









### 设计原则

* 设计之开始便考虑节能性。 Drone 鼓励用中断驱动的执行模型。

* 硬实时。 Drone 依赖于原子操作而非用资源临界区。

* 具有严格优先级的完全抢占式多任务处理。 优先级较高的任务优先，延迟最小。

* 高并发。 遵循 Rust 的[无畏并发](https://rustwiki.org/zh-CN/book/ch16-00-concurrency.html#无畏并发) `Fearless Concurrency`原则，多任务既简单又安全。

* 消息传递并发。 Drone附带开箱即用的同步原语。

* 默认为单栈。 无人机并发原语本质上是无堆栈状态机。 但是仍然支持堆栈任务。

* 启用动态内存。 可以使用方便的数据结构，如可变字符串或向量，同时仍然保持确定性和代码效率。



> 无畏并发
>
> Rust 的所有权和类型系统是一系列解决内存安全 和 并发问题的强有力的工具！通过利用所有权和类型检查，在 Rust 中很多并发错误都是 编译时 错误，而非运行时错误。因此，相比花费大量时间尝试重现运行时并发 bug 出现的特定情况，Rust 会拒绝编译不正确的代码并提供解释问题的错误信息。因此，你可以在开发时修复代码，而不是在部署到生产环境后修复代码。我们给 Rust 的这一部分起了一个绰号 无畏并发（fearless concurrency）。
>
> Rust 的并发支持工具：
>
> * 创建线程。如 std::thread::spawn ;
> * 消息传递。如通道channel ;
> * 共享状态。如std::sync::{Mutex, Arc} ;
> * Sync 和 Send trait 。将 Rust 的并发保证 扩展到用户定义和标准库的类型中。





## 不足

1. 不支持加载动态应用程序。操作系统与它的应用程序是静态链接的。

2. 执行模型没有实现时间切片。未来可能会增加可选的时间切片。


